from game.model.Facility import _Facility, Habitation, Farm, Baracks, Sawmill
from game.model.Resources import Resources
from game.model.tree.Tree import TechnologyTree, ActionTree
from game.model.tree.TreeNode import TechnologyNode
from game.view import prompt
from game.view.prompt import userInputInt, promptStatus
from game.model.Fight import Fight
from game.model.Troups import _Troup
from game.model.Troups import UnitGroup
from model.List import List, ListDeCon
from game.model.Campaign import Campaign

class Player :
	"""
	This class represents a player which is playing the game.
	A player has a name, a city, resources, technologies and bonuses.
	"""

	def __init__(self) :
		self.name = None
		self.city = None
		self.resources = Resources(wood=10, stone=5, food=10, knowledge=3) #Starting resources
		self.troups = List()
		self.technoTree = TechnologyTree(self)
		self.actionTree = ActionTree(self)
		self.god = None
		self.bonus = Resources(knowledge=1)
	
	def __str__(self) -> str :
		return self.name

	def startTurn(self) -> None :
		promptStatus(None)
		userInputInt(f"À toi de jouer, {self.name} !\n[0] Commencer", 0, 0)
		self.collectResources()
		self.consumeFood()
		self.actionTree.navigate()

	# RESOURCES

	def createStartingFacilities(self) -> None :
		self.city.facilities.add(Habitation()) # Je suis une merde T-T
		self.city.facilities.add(Farm())
		self.city.facilities.add(Sawmill())
	
	def collectResources(self) -> None :
		"""
		Collects all the resources generated by each of its facilities.
		This function is called each turn.
		"""
		length = self.city.facilities.len
		for i in range(length) :
			gain = self.city.facilities.get(i).getGain()
			if isinstance(gain, int) :
				self.city.maxPopulation += gain # Case of habitations
			else :
				self.resources.add(gain)
			self.resources.add(self.bonus)
	
	def consumeFood(self) -> bool :
		"""
		Deduces the food amount, based on the current player's city's population.
		:return: bool True if there is no food available, else False if everything is ok
		"""
		self.resources.food -= self.city.population
		if self.resources.food < 0 :
			return True
		return False

	# FACILITIES

	def promptFacilities(self) -> None :
		facilities = self.city.facilities
		for i in range(facilities.len) :
			facilities.get(i).promptSummary()
	
	def buildFacility(self, facility : _Facility) -> None :

		facility.promptDetails()

		if not self.city.checkPopulation() :
			select = userInputInt("[0] Retour\n[X] Construire (Population maximale déjà atteinte)", 0, 0)
		if self.resources.isGreaterOrEqualThan(facility.cost) :
			select = userInputInt("[0] Retour\n[X] Construire (Ressources insuffisantes)", 0, 0)
		else :
			select = userInputInt("[0] Retour\n[1] Construire", 0, 1)
		
		if select == 1 :
			self.city.addFacility(facility)

	# TECHNOLOGIES
	
	def learnTechnology(self, technology : TechnologyNode) -> bool :
		if self.resources.knowledge >= technology.cost :
			self.resources.knowledge -= technology.cost
			technology.unlocked = True
			return True
		return False
	
	# ARMY

	def promptTroups(self) -> None :
		baracks = self.city.facilities.onlyInstanceOf(Baracks())
		for i in range(self.troups.len) :
			print(self.troups.get(i).summary())

	def canAddTroup(self) -> bool : 
		nbBaracks = self.city.facilities.onlyInstanceOf(Baracks()).len
		if 4 * nbBaracks - self.troups.len > 0 :
			return True
		return False

	def addTroup(self, troup : _Troup) -> None :
		print(troup.details())
		if not self.city.checkPopulation() :
			choice = userInputInt("Former cette unité ?\n[0] Retour\n[X] Former (Population max déjà atteinte)", 0, 0)
		elif not self.canAddTroup() :
			choice = userInputInt("Former cette unité ?\n[0] Retour\n[X] Former (Construisez plus de casernes)", 0, 0)
		else :
			choice = userInputInt("Former cette unité ?\n[0] Retour\n[1] Former", 0, 1)

		if choice == 1 :
			if self.canAddTroup() and self.resources.isGreaterOrEqualThan(troup.cost) :
				self.troups.add(troup)
				self.resources.sub(troup.cost)
				self.city.population += 1
	
	def declareWar(self) -> None :
		cam = Campaign.getInstance()
		q = cam.playerQueue
		l = List()
		length = q.size()
		for i in range(length) :
			tmp = q.pop()
			l.add(tmp)
			q.push(tmp)
		promptStatus("CITE > ARMEE > GUERRE")
		print("[0] Retour")
		for i in range(length) :
			print(f"[{i+1}] {l.get(i)}")
		choice = userInputInt("", 0, length)

		if choice > 0 :

			enemy = l.get(choice - 1)
			fight = Fight(UnitGroup(self.choseTroups()), UnitGroup(enemy.choseTroups()))

			if fight.fight() == 1 :
				winner = self
				loser = enemy
			else :
				winner = enemy
				loser = enemy

			promptStatus("FIN DE BATAILLE")
			print(f"{winner} a gagné cette bataille !\n{winner} +10 DOM\n{loser} +2 DOM")

			winner.resources.domination += 10
			loser.resources.domination += 2

	def choseTroups(self):
		if self.troups.len < 4:
			troups = List()
			for i in range(self.troups.len):
				troups.add(self.troups.get(i))
		else:
			units = [random.randint(0,self.troups.len)]
			troups = List()
			added = set()
			while len(units) > 0:
				while units[0] in added:
					units[0] = random.randint(0, self.troups.len)
				added.add(units[0])
				troups.add(self.troups.get(units.pop(0)))
			
		return UnitGroup(troups)


